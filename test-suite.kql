// =============================================================================
// KustoX Extension Test Suite
// =============================================================================
// This file contains various complex Kusto queries to test the extension
// Run each query separately and compare results with expected outcomes
// =============================================================================

// TEST 1: Basic Data Retrieval
// Expected: 5 rows with basic storm event data
// Columns: StartTime, EndTime, EventType, State, DamageProperty
StormEvents
| take 5
| project StartTime, EndTime, EventType, State, DamageProperty

// TEST 2: Simple Aggregation (Your Original Problem Query)
// Expected: 1 row with aggregated data from single storm event
// Columns: EventType, State, TotalEvents, TotalDamage
StormEvents
| take 1
| project StartTime, EndTime, EventType, State, DamageProperty
| summarize TotalEvents = count(), TotalDamage = sum(DamageProperty) by EventType, State

// TEST 3: Multiple Aggregations
// Expected: Multiple rows grouped by EventType
// Columns: EventType, TotalEvents, AvgDamage, MaxDamage, MinDamage
StormEvents
| take 100
| summarize 
    TotalEvents = count(),
    AvgDamage = avg(DamageProperty),
    MaxDamage = max(DamageProperty),
    MinDamage = min(DamageProperty)
    by EventType
| order by TotalEvents desc

// TEST 4: Complex Filtering and Projection
// Expected: Tornado events in specific states with calculated fields
// Columns: StartTime, State, EventType, TotalDamage, DamageCategory
StormEvents
| where EventType == "Tornado"
| where State in ("TEXAS", "KANSAS", "OKLAHOMA")
| extend TotalDamage = DamageProperty + DamageCrops
| extend DamageCategory = case(
    TotalDamage == 0, "No Damage",
    TotalDamage < 10000, "Low",
    TotalDamage < 100000, "Medium",
    TotalDamage < 1000000, "High",
    "Severe"
)
| project StartTime, State, EventType, TotalDamage, DamageCategory
| order by TotalDamage desc
| take 10

// TEST 5: Time-based Analysis
// Expected: Monthly counts of storm events
// Columns: Month, EventCount
StormEvents
| extend Month = startofmonth(StartTime)
| summarize EventCount = count() by Month
| order by Month asc
| take 12

// TEST 6: Complex Join-like Operation with bin()
// Expected: Storm events grouped by time bins and damage ranges
// Columns: TimeBin, DamageRange, EventCount, AvgDamage
StormEvents
| where StartTime >= datetime(2007-01-01) and StartTime < datetime(2008-01-01)
| extend TimeBin = bin(StartTime, 30d)
| extend DamageRange = case(
    DamageProperty == 0, "None",
    DamageProperty < 50000, "Low",
    DamageProperty < 500000, "Medium",
    "High"
)
| summarize 
    EventCount = count(),
    AvgDamage = avg(DamageProperty)
    by TimeBin, DamageRange
| order by TimeBin, DamageRange

// TEST 7: String Operations and Pattern Matching
// Expected: Events with specific patterns in episode narrative
// Columns: State, EventType, NarrativeLength, HasWindMention
StormEvents
| where isnotempty(EpisodeNarrative)
| extend NarrativeLength = strlen(EpisodeNarrative)
| extend HasWindMention = EpisodeNarrative has_any ("wind", "Wind", "WIND")
| project State, EventType, NarrativeLength, HasWindMention
| where NarrativeLength > 100
| take 20

// TEST 8: Mathematical Operations and Functions
// Expected: Complex calculations on damage data
// Columns: State, TotalEvents, DamageStats, DamageRatio
StormEvents
| where DamageProperty > 0 or DamageCrops > 0
| summarize 
    TotalEvents = count(),
    TotalPropertyDamage = sum(DamageProperty),
    TotalCropDamage = sum(DamageCrops),
    AvgPropertyDamage = avg(DamageProperty),
    AvgCropDamage = avg(DamageCrops)
    by State
| extend DamageRatio = round(TotalPropertyDamage * 1.0 / (TotalPropertyDamage + TotalCropDamage), 3)
| extend DamageStats = strcat("P:", TotalPropertyDamage, " C:", TotalCropDamage)
| project State, TotalEvents, DamageStats, DamageRatio
| order by TotalPropertyDamage + TotalCropDamage desc
| take 15

// TEST 9: Complex Conditional Logic
// Expected: Events categorized by multiple criteria
// Columns: EventType, State, SeverityScore, Category, Description
StormEvents
| extend SeverityScore = 
    case(
        EventType in ("Tornado", "Hurricane"), 100,
        EventType in ("Thunderstorm Wind", "Hail"), 
            case(
                DamageProperty > 1000000, 80,
                DamageProperty > 100000, 60,
                40
            ),
        EventType in ("Flood", "Flash Flood"), 
            case(
                DeathsDirect > 0, 90,
                InjuriesDirect > 0, 70,
                DamageProperty > 500000, 60,
                30
            ),
        20
    )
| extend Category = case(
    SeverityScore >= 90, "Critical",
    SeverityScore >= 70, "High",
    SeverityScore >= 50, "Medium",
    "Low"
)
| extend Description = strcat(
    EventType, " in ", State, 
    " (Deaths: ", DeathsDirect, 
    ", Injuries: ", InjuriesDirect,
    ", Damage: $", DamageProperty, ")"
)
| project EventType, State, SeverityScore, Category, Description
| order by SeverityScore desc
| take 25

// TEST 10: Advanced Time Series Analysis
// Expected: Rolling statistics over time periods
// Columns: YearMonth, EventCount, RollingAvg, Trend
StormEvents
| extend YearMonth = startofmonth(StartTime)
| summarize EventCount = count() by YearMonth
| sort by YearMonth asc
| extend RollingAvg = round(avg(EventCount) over (order by YearMonth rows between 2 preceding and current row), 1)
| extend Trend = case(
    EventCount > RollingAvg * 1.2, "Increasing",
    EventCount < RollingAvg * 0.8, "Decreasing",
    "Stable"
)
| project YearMonth, EventCount, RollingAvg, Trend
| take 36

// TEST 11: Data Type Handling and Nulls
// Expected: Events with various data type operations
// Columns: State, EventType, HasDamage, FormattedDate, DataQuality
StormEvents
| extend HasDamage = case(
    isnull(DamageProperty) and isnull(DamageCrops), false,
    (DamageProperty + DamageCrops) > 0, true,
    false
)
| extend FormattedDate = format_datetime(StartTime, "yyyy-MM-dd HH:mm")
| extend DataQuality = case(
    isempty(EpisodeNarrative) and DamageProperty == 0, "Poor",
    isempty(EpisodeNarrative) or DamageProperty == 0, "Fair",
    "Good"
)
| project State, EventType, HasDamage, FormattedDate, DataQuality
| where DataQuality != "Poor"
| take 30

// TEST 12: Error-Prone Query (Should Fail)
// Expected: This should return an error due to invalid column name
// This tests error handling in the extension
StormEvents
| project InvalidColumnName, AnotherInvalidColumn
| take 5

// TEST 13: Empty Result Query
// Expected: Should return no rows but succeed
// Columns: StartTime, EventType, State
StormEvents
| where EventType == "NonExistentEventType"
| project StartTime, EventType, State

// TEST 14: Performance Test Query
// Expected: Large aggregation that might take some time
// Columns: State, EventType, YearMonth, TotalEvents, TotalDamage
StormEvents
| extend YearMonth = format_datetime(StartTime, "yyyy-MM")
| summarize 
    TotalEvents = count(),
    TotalDamage = sum(DamageProperty + DamageCrops),
    AvgMagnitude = avg(Magnitude)
    by State, EventType, YearMonth
| where TotalEvents >= 5
| order by TotalDamage desc
| take 100

// =============================================================================
// INSTRUCTIONS FOR TESTING:
// =============================================================================
// 1. Run each query individually by selecting it and pressing F5
// 2. Record the following for each test:
//    - Number of rows returned
//    - Column names returned
//    - First row data sample
//    - Execution time
//    - Any errors encountered
// 3. Pay special attention to:
//    - TEST 2: Your original problematic query
//    - TEST 12: Should fail with error
//    - TEST 13: Should return 0 rows but no error
//    - Complex queries (8-11): Should return calculated columns correctly
// =============================================================================
