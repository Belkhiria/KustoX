import { ColumnMapping } from "./columnMappings";
/**
 * Data formats supported for Kusto ingestion.
 */
export declare enum DataFormat {
    /**
     * Comma-separated value.
     */
    CSV = "csv",
    /**
     * Tab-separated value.
     */
    TSV = "tsv",
    /**
     * Semicolon-separated value (the unique Azure Storage log format).
     */
    SCSV = "scsv",
    /**
     * Start-Of-Header (CTRL-A)-separated value.
     */
    SOHSV = "sohsv",
    /**
     * Pipeline-separated value (used by Cosmos).
     */
    PSV = "psv",
    /**
     * Each record is a line and has just one field.
     */
    TXT = "txt",
    /**
     * Whole stream is a single record with a single field.
     */
    RAW = "raw",
    /**
     * Tab-separated value with '\' escaping character.
     */
    TSVE = "tsve",
    /**
     * Data is in a JSON format, each line is record with a single JSON value.
     */
    JSON = "json",
    /**
     * Data stream holds a single JSON value -- newlines are regular whitespace.
     */
    SINGLEJSON = "singlejson",
    /**
     * The data stream is a concatenation of JSON documents (property bags all).
     */
    MULTIJSON = "multijson",
    /**
     * Avro format.
     */
    AVRO = "avro",
    /**
     * Parquet format.
     */
    PARQUET = "parquet",
    /**
     * Microsoft Cosmos structured streams format
     */
    SSTREAM = "sstream",
    /**
     * The Optimized Row Columnar (ORC)
     */
    ORC = "orc",
    /**
     * Avro format for ingesting through avro2json.
     */
    APACHEAVRO = "apacheavro",
    /**
     * W3C Extended Log File format.
     */
    W3CLogFile = "w3clogfile"
}
export declare enum IngestionMappingKind {
    CSV = "Csv",
    JSON = "Json",
    AVRO = "Avro",
    PARQUET = "Parquet",
    SSTREAM = "SStream",
    ORC = "orc",
    APACHEAVRO = "ApacheAvro",
    W3CLOGFILE = "W3CLogFile"
}
export declare const dataFormatMappingKind: (dataFormat: DataFormat) => IngestionMappingKind;
export declare enum ValidationOptions {
    DoNotValidate = 0,
    ValidateCsvInputConstantColumns = 1,
    ValidateCsvInputColumnLevelOnly = 2
}
export declare enum ValidationImplications {
    Fail = 0,
    BestEffort = 1
}
export declare class ValidationPolicy {
    readonly validationOptions: ValidationOptions;
    readonly validationImplications: ValidationImplications;
    constructor(validationOptions?: ValidationOptions, validationImplications?: ValidationImplications);
    toJSON(): Record<string, number>;
}
export declare enum ReportLevel {
    FailuresOnly = 0,
    DoNotReport = 1,
    FailuresAndSuccesses = 2
}
export declare enum ReportMethod {
    Queue = 0,
    Table = 1,
    QueueAndTable = 2
}
export interface IngestionPropertiesFields {
    database?: string;
    table?: string;
    format?: DataFormat;
    /**
     * @deprecated. Use ingestionMappingColumns instead.
     */
    ingestionMapping?: ColumnMapping[];
    ingestionMappingColumns?: ColumnMapping[];
    ingestionMappingReference?: string;
    /**
     * @deprecated. Use ingestionMappingKind instead.
     */
    ingestionMappingType?: IngestionMappingKind;
    ingestionMappingKind?: IngestionMappingKind;
    additionalTags?: string;
    ingestIfNotExists?: string;
    ingestByTags?: string[];
    dropByTags?: string[];
    flushImmediately?: boolean;
    ignoreFirstRecord?: boolean;
    reportLevel?: ReportLevel;
    reportMethod?: ReportMethod;
    validationPolicy?: ValidationPolicy;
    additionalProperties?: {
        [additional: string]: any;
    } | null;
}
export interface IngestionProperties extends IngestionPropertiesFields {
}
export declare class IngestionProperties {
    constructor(data: Partial<IngestionPropertiesFields>);
    validate(): void;
    merge(extraProps: IngestionPropertiesInput): IngestionProperties;
    setDefaults(): void;
}
export type IngestionPropertiesInput = IngestionProperties | IngestionPropertiesFields | null | undefined;
export default IngestionProperties;
//# sourceMappingURL=ingestionProperties.d.ts.map