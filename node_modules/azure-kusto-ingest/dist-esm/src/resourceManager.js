"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceManager = exports.IngestClientResources = exports.ResourceURI = void 0;
const azure_kusto_data_1 = require("azure-kusto-data");
const retry_1 = require("./retry");
const storage_blob_1 = require("@azure/storage-blob");
const ATTEMPT_COUNT = 4;
class ResourceURI {
    constructor(uri) {
        this.uri = uri;
    }
}
exports.ResourceURI = ResourceURI;
class IngestClientResources {
    constructor(securedReadyForAggregationQueues = null, failedIngestionsQueues = null, successfulIngestionsQueues = null, containers = null) {
        this.securedReadyForAggregationQueues = securedReadyForAggregationQueues;
        this.failedIngestionsQueues = failedIngestionsQueues;
        this.successfulIngestionsQueues = successfulIngestionsQueues;
        this.containers = containers;
    }
    valid() {
        const resources = [this.securedReadyForAggregationQueues, this.failedIngestionsQueues, this.failedIngestionsQueues, this.containers];
        return resources.reduce((prev, current) => !!(prev && current), true);
    }
}
exports.IngestClientResources = IngestClientResources;
class ResourceManager {
    constructor(kustoClient, isBrowser = false) {
        this.kustoClient = kustoClient;
        this.isBrowser = isBrowser;
        this.baseSleepTimeSecs = 1;
        this.baseJitterSecs = 1;
        this.refreshPeriod = azure_kusto_data_1.TimeUtils.toMilliseconds(1, 0, 0);
        this.refreshPeriodOnError = azure_kusto_data_1.TimeUtils.toMilliseconds(0, 10, 0);
        this.ingestClientResources = null;
        this.ingestClientResourcesLastUpdate = null;
        this.authorizationContext = null;
        this.authorizationContextLastUpdate = null;
    }
    async refreshIngestClientResources() {
        const error = await this.tryRefresh(false);
        if (!this.ingestClientResources) {
            throw new Error(`Failed to fetch ingestion resources from service.  ${error === null || error === void 0 ? void 0 : error.message}.\n ${error === null || error === void 0 ? void 0 : error.stack}`);
        }
        return this.ingestClientResources;
    }
    async getIngestClientResourcesFromService() {
        const retry = new retry_1.ExponentialRetry(ATTEMPT_COUNT, this.baseSleepTimeSecs, this.baseJitterSecs);
        while (retry.shouldTry()) {
            try {
                const cmd = `.get ingestion resources ${this.isBrowser ? `with (EnableBlobCors='true', EnableQueueCors='true', EnableTableCors='true')` : ""}`;
                const response = await this.kustoClient.execute("NetDefaultDB", cmd);
                const table = response.primaryResults[0];
                const resoures = new IngestClientResources(this.getResourceByName(table, "SecuredReadyForAggregationQueue"), this.getResourceByName(table, "FailedIngestionsQueue"), this.getResourceByName(table, "SuccessfulIngestionsQueue"), this.getResourceByName(table, "TempStorage"));
                if (!resoures.valid()) {
                    throw new Error("Unexpected error occured - fetched data returned missing resource");
                }
                return resoures;
            }
            catch (error) {
                if (!(error instanceof azure_kusto_data_1.KustoDataErrors.ThrottlingError)) {
                    throw error;
                }
                await retry.backoff();
            }
        }
        throw new Error(`Failed to get ingestion resources from server - the request was throttled ${ATTEMPT_COUNT} times.`);
    }
    getResourceByName(table, resourceName) {
        const result = [];
        for (const row of table.rows()) {
            const typedRow = row;
            if (typedRow.ResourceTypeName === resourceName) {
                result.push(new ResourceURI(typedRow.StorageRoot));
            }
        }
        return result;
    }
    async refreshAuthorizationContext() {
        const error = await this.tryRefresh(true);
        if (this.authorizationContext == null) {
            throw new Error(`Failed to fetch Authorization context from service.  ${error === null || error === void 0 ? void 0 : error.message}.\n ${error === null || error === void 0 ? void 0 : error.stack}`);
        }
        return this.authorizationContext;
    }
    async tryRefresh(isAuthContextFetch) {
        var _a;
        const resource = isAuthContextFetch ? (_a = this.authorizationContext) === null || _a === void 0 ? void 0 : _a.trim() : this.ingestClientResources;
        const lastRefresh = isAuthContextFetch ? this.authorizationContextLastUpdate : this.ingestClientResourcesLastUpdate;
        const now = Date.now();
        let error = null;
        if (!resource || !lastRefresh || lastRefresh + this.refreshPeriod <= now) {
            try {
                if (isAuthContextFetch) {
                    this.authorizationContext = await this.getAuthorizationContextFromService();
                    this.authorizationContextLastUpdate = now;
                }
                else {
                    this.ingestClientResources = await this.getIngestClientResourcesFromService();
                    this.ingestClientResourcesLastUpdate = now;
                }
            }
            catch (e) {
                error = e;
            }
        }
        return error;
    }
    async getAuthorizationContextFromService() {
        const retry = new retry_1.ExponentialRetry(ATTEMPT_COUNT, this.baseSleepTimeSecs, this.baseJitterSecs);
        while (retry.shouldTry()) {
            try {
                const response = await this.kustoClient.execute("NetDefaultDB", ".get kusto identity token");
                const next = response.primaryResults[0].rows().next();
                if (next.done) {
                    throw new Error("Failed to get authorization context - got empty results");
                }
                return next.value.toJSON().AuthorizationContext;
            }
            catch (error) {
                if (!(error instanceof azure_kusto_data_1.KustoDataErrors.ThrottlingError)) {
                    throw error;
                }
                await retry.backoff();
            }
        }
        throw new Error(`Failed to get identity token from server - the request was throttled ${ATTEMPT_COUNT} times.`);
    }
    async getIngestionQueues() {
        return (await this.refreshIngestClientResources()).securedReadyForAggregationQueues;
    }
    async getFailedIngestionsQueues() {
        return (await this.refreshIngestClientResources()).failedIngestionsQueues;
    }
    async getSuccessfulIngestionsQueues() {
        return (await this.refreshIngestClientResources()).successfulIngestionsQueues;
    }
    async getContainers() {
        return (await this.refreshIngestClientResources()).containers;
    }
    async getAuthorizationContext() {
        return this.refreshAuthorizationContext();
    }
    async getBlockBlobClient(blobName) {
        const containers = await this.getContainers();
        if (containers == null) {
            throw new Error("Failed to get containers");
        }
        const container = containers[Math.floor(Math.random() * containers.length)];
        const containerClient = new storage_blob_1.ContainerClient(container.uri);
        return containerClient.getBlockBlobClient(blobName);
    }
    close() {
        this.kustoClient.close();
    }
}
exports.ResourceManager = ResourceManager;
exports.default = ResourceManager;
//# sourceMappingURL=resourceManager.js.map