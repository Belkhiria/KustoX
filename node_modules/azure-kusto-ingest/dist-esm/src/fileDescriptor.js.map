{"version":3,"file":"fileDescriptor.js","sourceRoot":"","sources":["../../src/fileDescriptor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport zlib from \"zlib\";\nimport pathlib from \"path\";\nimport fs from \"fs\";\nimport { file as tmpFile } from \"tmp-promise\";\nimport { promisify } from \"util\";\nimport { AbstractDescriptor, CompressionType, FileDescriptorBase, shouldCompressFileByExtension } from \"./descriptors.js\";\nimport { IngestionPropertiesInput, shouldCompressFileByFormat } from \"./ingestionProperties.js\";\n\n/**\n * Describes a file to be ingested. Use string to describe a local path in Node.JS and Blob object in browsers\n */\nexport class FileDescriptor extends AbstractDescriptor implements FileDescriptorBase {\n    zipped: boolean;\n    compressionType: CompressionType;\n    shouldNotCompress: boolean;\n    cleanupTmp?: () => Promise<void>;\n\n    constructor(\n        /**\n         * Use string in Node.JS and Blob in browser\n         */\n        readonly file: string | Blob,\n        sourceId: string | null = null,\n        size: number | null = null,\n        compressionType: CompressionType = CompressionType.None,\n        readonly extension?: string, // Extracted from file name by default\n        readonly name?: string, // Extracted from file name by default\n    ) {\n        super(sourceId, size);\n        this.compressionType = compressionType;\n        this.name = name ? name : pathlib.basename(this.file as string);\n        this.extension = extension ? extension : pathlib.extname(this.file as string).toLowerCase();\n\n        this.zipped = compressionType !== CompressionType.None || this.extension === \".gz\" || this.extension === \".zip\";\n        this.shouldNotCompress = !shouldCompressFileByExtension(this.extension);\n    }\n\n    async _gzip(): Promise<string> {\n        const { path, cleanup } = await tmpFile({ postfix: \".gz\", keep: false });\n        this.cleanupTmp = cleanup;\n\n        const zipper = zlib.createGzip();\n        const input = fs.createReadStream(this.file as string, { autoClose: true });\n        const output = fs.createWriteStream(path);\n\n        await new Promise((resolve, reject) => {\n            input\n                .pipe(zipper)\n                .pipe(output)\n                .on(\"error\", (err) => {\n                    reject(err);\n                });\n            output.once(\"close\", () => {\n                resolve(null);\n            });\n        });\n\n        return path;\n    }\n\n    async prepare(ingestionProperties?: IngestionPropertiesInput): Promise<string> {\n        const shouldNotCompressByFormat = !shouldCompressFileByFormat(ingestionProperties);\n        if (this.zipped || this.shouldNotCompress || shouldNotCompressByFormat) {\n            const estimatedCompressionModifier = 11;\n            await this._calculateSize(estimatedCompressionModifier);\n            return this.file as string;\n        }\n\n        const path = await this._gzip();\n        await this._calculateSize();\n        return path;\n    }\n\n    private async _calculateSize(modifier: number = 1): Promise<void> {\n        if (this.size == null || this.size <= 0) {\n            const asyncStat = promisify(fs.stat);\n            this.size = (await asyncStat(this.file as string)).size * modifier;\n        }\n    }\n\n    async cleanup(): Promise<void> {\n        if (this.cleanupTmp) {\n            await this.cleanupTmp();\n        }\n    }\n\n    getCompressionSuffix() {\n        return this.compressionType ? `.${this.compressionType}` : \".gz\";\n    }\n}\n"]}