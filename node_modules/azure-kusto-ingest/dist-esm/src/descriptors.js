"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBlobName = exports.BlobDescriptor = exports.StreamDescriptor = exports.AbstractDescriptor = exports.getSourceId = exports.CompressionType = void 0;
const uuid_1 = require("uuid");
const uuid_validate_1 = __importDefault(require("uuid-validate"));
const storage_blob_1 = require("@azure/storage-blob");
var CompressionType;
(function (CompressionType) {
    CompressionType["ZIP"] = ".zip";
    CompressionType["GZIP"] = ".gz";
    CompressionType["None"] = "";
})(CompressionType || (exports.CompressionType = CompressionType = {}));
const getSourceId = (sourceId) => {
    if (sourceId) {
        if (!(0, uuid_validate_1.default)(sourceId, 4)) {
            throw Error("sourceId is not a valid uuid/v4");
        }
        return sourceId;
    }
    return (0, uuid_1.v4)();
};
exports.getSourceId = getSourceId;
class AbstractDescriptor {
    constructor(sourceId = null, size = null) {
        this.sourceId = sourceId;
        this.size = size;
        this.sourceId = (0, exports.getSourceId)(sourceId);
    }
}
exports.AbstractDescriptor = AbstractDescriptor;
class StreamDescriptor extends AbstractDescriptor {
    /**
     * Use Readable for Node.js and ArrayBuffer in browser
     */
    constructor(stream, sourceId = null, compressionType = CompressionType.None, size = null) {
        super(sourceId, size);
        this.stream = stream;
        this.compressionType = compressionType;
    }
    merge(other) {
        this.size = other.size;
        this.compressionType = other.compressionType;
        this.sourceId = other.sourceId;
        return this;
    }
    // Currently streams are not compressed by us
    getCompressionSuffix() {
        return this.compressionType ? `.${this.compressionType}` : "";
    }
}
exports.StreamDescriptor = StreamDescriptor;
class BlobDescriptor extends AbstractDescriptor {
    constructor(path, size = null, sourceId = null) {
        super(sourceId, size);
        this.path = path;
    }
    async fillSize() {
        if (!this.size) {
            const blobClient = new storage_blob_1.BlobClient(this.path);
            const blobProps = await blobClient.getProperties();
            const length = blobProps.contentLength;
            if (length !== undefined) {
                if (length === 0) {
                    throw new Error("Empty blob.");
                }
                this.size = length;
            }
        }
    }
}
exports.BlobDescriptor = BlobDescriptor;
const generateBlobName = (desc, props) => {
    const extension = desc instanceof StreamDescriptor ? null : `${desc.name ? "__" + desc.name : `${desc.extension ? "." + desc.extension : ""}`}`;
    const formatSuffix = props.format ? `.${props.format}` : ".csv";
    const compressionString = desc.getCompressionSuffix();
    return `${props.database}__${props.table}__${desc.sourceId}${extension || formatSuffix}${compressionString}`;
};
exports.generateBlobName = generateBlobName;
//# sourceMappingURL=descriptors.js.map