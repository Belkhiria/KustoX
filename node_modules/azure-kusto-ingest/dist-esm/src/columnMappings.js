// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/* eslint-disable @typescript-eslint/ban-types -- We legitimately want to use {} as a "any non-nullable type" */
import { IngestionMappingKind } from "./ingestionProperties.js";
export var FieldTransformation;
(function (FieldTransformation) {
    FieldTransformation["PropertyBagArrayToDictionary"] = "PropertyBagArrayToDictionary";
    FieldTransformation["DateTimeFromUnixSeconds"] = "DateTimeFromUnixSeconds";
    FieldTransformation["DateTimeFromUnixMilliseconds"] = "DateTimeFromUnixMilliseconds";
    FieldTransformation["DateTimeFromUnixMicroseconds"] = "DateTimeFromUnixMicroseconds";
    FieldTransformation["DateTimeFromUnixNanoseconds"] = "DateTimeFromUnixNanoseconds";
})(FieldTransformation || (FieldTransformation = {}));
export var ConstantTransformation;
(function (ConstantTransformation) {
    ConstantTransformation["SourceLocation"] = "SourceLocation";
    ConstantTransformation["SourceLineNumber"] = "SourceLineNumber";
})(ConstantTransformation || (ConstantTransformation = {}));
export class ColumnMapping {
    constructor(columnName, cslDataType, Properties) {
        this.columnName = columnName;
        this.cslDataType = cslDataType;
        this.Properties = Properties;
    }
    toApiMapping() {
        const result = {
            Column: this.columnName,
        };
        if (this.cslDataType) {
            result.DataType = this.cslDataType;
        }
        if (this.Properties) {
            result.Properties = {};
            for (const key in this.Properties) {
                if (Object.prototype.hasOwnProperty.call(this.Properties, key)) {
                    const typedKey = key;
                    const property = this.Properties[typedKey];
                    // We don't do if (property) because we '0' is a legitimate value
                    if (property !== undefined && property !== null) {
                        result.Properties[typedKey] = property.toString();
                    }
                }
            }
        }
        return result;
    }
}
export class CsvColumnMapping extends ColumnMapping {
    /**
     * @deprecated Use the factory methods instead.
     */
    constructor(columnName, cslDataType, ordinal, constantValue) {
        super(columnName, cslDataType, {
            Ordinal: ordinal === undefined ? undefined : parseInt(ordinal, 10),
            ConstValue: constantValue,
        });
        this.columnName = columnName;
        this.cslDataType = cslDataType;
        this.ordinal = ordinal;
        this.mappingKind = IngestionMappingKind.CSV;
    }
    static withOrdinal(columnName, ordinal, cslDataType) {
        return new CsvColumnMapping(columnName, cslDataType, ordinal.toString());
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new CsvColumnMapping(columnName, cslDataType, undefined, constantValue);
    }
}
export class JsonColumnMapping extends ColumnMapping {
    /**
     * @deprecated Use the factory methods instead.
     */
    constructor(columnName, jsonPath, cslDataType = null, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: jsonPath,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.jsonPath = jsonPath;
        this.mappingKind = IngestionMappingKind.JSON;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new JsonColumnMapping(columnName, path, cslDataType, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new JsonColumnMapping(columnName, undefined, cslDataType, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new JsonColumnMapping(columnName, undefined, cslDataType, undefined, transform);
    }
}
export class AvroColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = IngestionMappingKind.AVRO;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new AvroColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new AvroColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new AvroColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new AvroColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
export class ApacheAvroColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = IngestionMappingKind.APACHEAVRO;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
export class SStreamColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = IngestionMappingKind.SSTREAM;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new SStreamColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new SStreamColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new SStreamColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new SStreamColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
export class ParquetColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = IngestionMappingKind.PARQUET;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new ParquetColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new ParquetColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new ParquetColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new ParquetColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
export class OrcColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = IngestionMappingKind.ORC;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new OrcColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new OrcColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new OrcColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new OrcColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
export class W3CLogFileMapping extends ColumnMapping {
    constructor(columnName, cslDataType, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, { Field: field, ConstValue: constantValue, Transform: transform });
        this.columnName = columnName;
        this.mappingKind = IngestionMappingKind.W3CLOGFILE;
    }
    static withField(columnName, field, cslDataType, transform) {
        return new W3CLogFileMapping(columnName, cslDataType, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new W3CLogFileMapping(columnName, cslDataType, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new W3CLogFileMapping(columnName, cslDataType, undefined, undefined, transform);
    }
}
//# sourceMappingURL=columnMappings.js.map