"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.W3CLogFileMapping = exports.OrcColumnMapping = exports.ParquetColumnMapping = exports.SStreamColumnMapping = exports.ApacheAvroColumnMapping = exports.AvroColumnMapping = exports.JsonColumnMapping = exports.CsvColumnMapping = exports.ColumnMapping = exports.ConstantTransformation = exports.FieldTransformation = void 0;
/* eslint-disable @typescript-eslint/ban-types -- We legitimately want to use {} as a "any non-nullable type" */
const ingestionProperties_1 = require("./ingestionProperties");
var FieldTransformation;
(function (FieldTransformation) {
    FieldTransformation["PropertyBagArrayToDictionary"] = "PropertyBagArrayToDictionary";
    FieldTransformation["DateTimeFromUnixSeconds"] = "DateTimeFromUnixSeconds";
    FieldTransformation["DateTimeFromUnixMilliseconds"] = "DateTimeFromUnixMilliseconds";
    FieldTransformation["DateTimeFromUnixMicroseconds"] = "DateTimeFromUnixMicroseconds";
    FieldTransformation["DateTimeFromUnixNanoseconds"] = "DateTimeFromUnixNanoseconds";
})(FieldTransformation || (exports.FieldTransformation = FieldTransformation = {}));
var ConstantTransformation;
(function (ConstantTransformation) {
    ConstantTransformation["SourceLocation"] = "SourceLocation";
    ConstantTransformation["SourceLineNumber"] = "SourceLineNumber";
})(ConstantTransformation || (exports.ConstantTransformation = ConstantTransformation = {}));
class ColumnMapping {
    constructor(columnName, cslDataType, Properties) {
        this.columnName = columnName;
        this.cslDataType = cslDataType;
        this.Properties = Properties;
    }
    toApiMapping() {
        const result = {
            Column: this.columnName,
        };
        if (this.cslDataType) {
            result.DataType = this.cslDataType;
        }
        if (this.Properties) {
            result.Properties = {};
            for (const key in this.Properties) {
                if (Object.prototype.hasOwnProperty.call(this.Properties, key)) {
                    const typedKey = key;
                    const property = this.Properties[typedKey];
                    // We don't do if (property) because we '0' is a legitimate value
                    if (property !== undefined && property !== null) {
                        result.Properties[typedKey] = property.toString();
                    }
                }
            }
        }
        return result;
    }
}
exports.ColumnMapping = ColumnMapping;
class CsvColumnMapping extends ColumnMapping {
    /**
     * @deprecated Use the factory methods instead.
     */
    constructor(columnName, cslDataType, ordinal, constantValue) {
        super(columnName, cslDataType, {
            Ordinal: ordinal === undefined ? undefined : parseInt(ordinal, 10),
            ConstValue: constantValue,
        });
        this.columnName = columnName;
        this.cslDataType = cslDataType;
        this.ordinal = ordinal;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.CSV;
    }
    static withOrdinal(columnName, ordinal, cslDataType) {
        return new CsvColumnMapping(columnName, cslDataType, ordinal.toString());
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new CsvColumnMapping(columnName, cslDataType, undefined, constantValue);
    }
}
exports.CsvColumnMapping = CsvColumnMapping;
class JsonColumnMapping extends ColumnMapping {
    /**
     * @deprecated Use the factory methods instead.
     */
    constructor(columnName, jsonPath, cslDataType = null, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: jsonPath,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.jsonPath = jsonPath;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.JSON;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new JsonColumnMapping(columnName, path, cslDataType, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new JsonColumnMapping(columnName, undefined, cslDataType, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new JsonColumnMapping(columnName, undefined, cslDataType, undefined, transform);
    }
}
exports.JsonColumnMapping = JsonColumnMapping;
class AvroColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.AVRO;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new AvroColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new AvroColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new AvroColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new AvroColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
exports.AvroColumnMapping = AvroColumnMapping;
class ApacheAvroColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.APACHEAVRO;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new ApacheAvroColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
exports.ApacheAvroColumnMapping = ApacheAvroColumnMapping;
class SStreamColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.SSTREAM;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new SStreamColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new SStreamColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new SStreamColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new SStreamColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
exports.SStreamColumnMapping = SStreamColumnMapping;
class ParquetColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.PARQUET;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new ParquetColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new ParquetColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new ParquetColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new ParquetColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
exports.ParquetColumnMapping = ParquetColumnMapping;
class OrcColumnMapping extends ColumnMapping {
    constructor(columnName, cslDataType, path, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, {
            Path: path,
            Field: field,
            ConstValue: constantValue,
            Transform: transform,
        });
        this.columnName = columnName;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.ORC;
    }
    static withPath(columnName, path, cslDataType, transform) {
        return new OrcColumnMapping(columnName, cslDataType, path, undefined, undefined, transform);
    }
    static withField(columnName, field, cslDataType, transform) {
        return new OrcColumnMapping(columnName, cslDataType, undefined, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new OrcColumnMapping(columnName, cslDataType, undefined, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new OrcColumnMapping(columnName, cslDataType, undefined, undefined, undefined, transform);
    }
}
exports.OrcColumnMapping = OrcColumnMapping;
class W3CLogFileMapping extends ColumnMapping {
    constructor(columnName, cslDataType, field, constantValue, transform) {
        super(columnName, cslDataType !== null && cslDataType !== void 0 ? cslDataType : undefined, { Field: field, ConstValue: constantValue, Transform: transform });
        this.columnName = columnName;
        this.mappingKind = ingestionProperties_1.IngestionMappingKind.W3CLOGFILE;
    }
    static withField(columnName, field, cslDataType, transform) {
        return new W3CLogFileMapping(columnName, cslDataType, field, undefined, transform);
    }
    static withConstantValue(columnName, constantValue, cslDataType) {
        return new W3CLogFileMapping(columnName, cslDataType, undefined, constantValue);
    }
    static withTransform(columnName, transform, cslDataType) {
        return new W3CLogFileMapping(columnName, cslDataType, undefined, undefined, transform);
    }
}
exports.W3CLogFileMapping = W3CLogFileMapping;
//# sourceMappingURL=columnMappings.js.map