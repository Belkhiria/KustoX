{"version":3,"file":"ingestClient.js","sourceRoot":"","sources":["../../src/ingestClient.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAIlC,+CAAmF;AACnF,qDAAkD;AAKlD,yDAA2D;AAG3D,MAAa,iBAAkB,SAAQ,wCAAqB;IACxD,YAAY,IAA2C,EAAE,YAAuC;QAC5F,KAAK,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,cAAc,CAAC,IAAoC,EAAE,mBAA8C;QACrG,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,MAAM,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,CAAC;QAExD,MAAM,UAAU,GAAG,IAAI,YAAY,+BAAc,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,+BAAc,CAAC,IAAI,CAAC,CAAC;QAEpF,IAAI;YACA,MAAM,QAAQ,GAAG,IAAA,8BAAgB,EAAC,UAAU,EAAE,KAAK,CAAC,CAAC;YACrD,MAAM,CAAC,YAAY,EAAE,eAAe,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACrI,MAAM,eAAe,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;YAC/C,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,4BAAc,CAAC,eAAe,CAAC,GAAG,EAAE,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC,CAAC;SACpH;gBAAS;YACN,MAAM,UAAU,CAAC,OAAO,EAAE,CAAC;SAC9B;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,gBAAgB,CAClB,MAAiD,EACjD,mBAA8C;QAE9C,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,MAAM,KAAK,GAAG,IAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,CAAC;QACxD,MAAM,UAAU,GAAqB,MAAM,YAAY,8BAAgB,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,8BAAgB,CAAC,MAAM,CAAC,CAAC;QAEhH,MAAM,QAAQ,GAAG,IAAA,8BAAgB,EAAC,UAAU,EAAE,KAAK,CAAC,CAAC;QAErD,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAChF,IAAI,UAAU,CAAC,MAAM,YAAY,MAAM,EAAE;YACrC,MAAM,eAAe,CAAC,UAAU,CAAC,UAAU,CAAC,MAAgB,CAAC,CAAC;SACjE;aAAM;YACH,MAAM,eAAe,CAAC,YAAY,CAAC,UAAU,CAAC,MAAkB,CAAC,CAAC;SACrE;QAED,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,4BAAc,CAAC,eAAe,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,mBAAmB;IACnG,CAAC;CACJ;AA9CD,8CA8CC;AAED,kBAAe,iBAAiB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { KustoConnectionStringBuilder } from \"azure-kusto-data\";\n\nimport { BlobDescriptor, generateBlobName, StreamDescriptor } from \"./descriptors\";\nimport { FileDescriptor } from \"./fileDescriptor\";\n\nimport { QueueSendMessageResponse } from \"@azure/storage-queue\";\n\nimport { IngestionPropertiesInput } from \"./ingestionProperties\";\nimport { KustoIngestClientBase } from \"./ingestClientBase\";\nimport { Readable } from \"stream\";\n\nexport class KustoIngestClient extends KustoIngestClientBase {\n    constructor(kcsb: string | KustoConnectionStringBuilder, defaultProps?: IngestionPropertiesInput) {\n        super(kcsb, defaultProps);\n    }\n\n    /**\n     * Use string in Node.JS and Blob in browser\n     */\n    async ingestFromFile(file: FileDescriptor | string | Blob, ingestionProperties?: IngestionPropertiesInput): Promise<QueueSendMessageResponse> {\n        this.ensureOpen();\n        const props = this._getMergedProps(ingestionProperties);\n\n        const descriptor = file instanceof FileDescriptor ? file : new FileDescriptor(file);\n\n        try {\n            const blobName = generateBlobName(descriptor, props);\n            const [fileToUpload, blockBlobClient] = await Promise.all([descriptor.prepare(), this.resourceManager.getBlockBlobClient(blobName)]);\n            await blockBlobClient.uploadFile(fileToUpload);\n            return this.ingestFromBlob(new BlobDescriptor(blockBlobClient.url, descriptor.size, descriptor.sourceId), props);\n        } finally {\n            await descriptor.cleanup();\n        }\n    }\n\n    /**\n     * Use Readable in Node.JS and ArrayBuffer in browser\n     */\n    async ingestFromStream(\n        stream: StreamDescriptor | Readable | ArrayBuffer,\n        ingestionProperties?: IngestionPropertiesInput\n    ): Promise<QueueSendMessageResponse> {\n        this.ensureOpen();\n        const props = this._getMergedProps(ingestionProperties);\n        const descriptor: StreamDescriptor = stream instanceof StreamDescriptor ? stream : new StreamDescriptor(stream);\n\n        const blobName = generateBlobName(descriptor, props);\n\n        const blockBlobClient = await this.resourceManager.getBlockBlobClient(blobName);\n        if (descriptor.stream instanceof Buffer) {\n            await blockBlobClient.uploadData(descriptor.stream as Buffer);\n        } else {\n            await blockBlobClient.uploadStream(descriptor.stream as Readable);\n        }\n\n        return this.ingestFromBlob(new BlobDescriptor(blockBlobClient.url), props); // descriptor.size?\n    }\n}\n\nexport default KustoIngestClient;\n"]}