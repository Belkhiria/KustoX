"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_util_1 = require("@azure/core-util");
const azure_kusto_data_1 = require("azure-kusto-data");
const abstractKustoClient_1 = require("./abstractKustoClient");
const descriptors_1 = require("./descriptors");
const fileDescriptor_1 = require("./fileDescriptor");
const ingestClient_1 = __importDefault(require("./ingestClient"));
const retry_1 = require("./retry");
const streamUtils_1 = require("./streamUtils");
const streamingIngestClient_1 = __importDefault(require("./streamingIngestClient"));
const maxStreamSize = 1024 * 1024 * 4;
const attemptCount = 3;
const ingestPrefix = "https://ingest-";
class KustoManagedStreamingIngestClient extends abstractKustoClient_1.AbstractKustoClient {
    /**
     * Creates a KustoManagedStreamingIngestClient from a DM connection string.
     * This method infers the engine connection string.
     * For advanced usage, use the constructor that takes a DM connection string and an engine connection string.
     *
     * @param dmConnectionString The DM connection string.
     * @param defaultProps The default ingestion properties.
     */
    static fromDmConnectionString(dmConnectionString, defaultProps) {
        var _a;
        if (dmConnectionString.dataSource == null || !dmConnectionString.dataSource.startsWith(ingestPrefix)) {
            throw new Error(`DM connection string must include the prefix '${ingestPrefix}'`);
        }
        const engineConnectionString = azure_kusto_data_1.KustoConnectionStringBuilder.fromExisting(dmConnectionString);
        engineConnectionString.dataSource = (_a = engineConnectionString.dataSource) === null || _a === void 0 ? void 0 : _a.replace(ingestPrefix, "https://");
        return new KustoManagedStreamingIngestClient(engineConnectionString, dmConnectionString, defaultProps);
    }
    /**
     * Creates a KustoManagedStreamingIngestClient from a engine connection string.
     * This method infers the engine connection string.
     * For advanced usage, use the constructor that takes an engine connection string and an engine connection string.
     *
     * @param engineConnectionString The engine connection string.
     * @param defaultProps The default ingestion properties.
     */
    static fromEngineConnectionString(engineConnectionString, defaultProps) {
        var _a;
        if (engineConnectionString.dataSource == null || engineConnectionString.dataSource.startsWith(ingestPrefix)) {
            throw new Error(`Engine connection string must not include the prefix '${ingestPrefix}'`);
        }
        const dmConnectionString = azure_kusto_data_1.KustoConnectionStringBuilder.fromExisting(engineConnectionString);
        dmConnectionString.dataSource = (_a = dmConnectionString.dataSource) === null || _a === void 0 ? void 0 : _a.replace("https://", ingestPrefix);
        return new KustoManagedStreamingIngestClient(engineConnectionString, dmConnectionString, defaultProps);
    }
    constructor(engineKcsb, dmKcsb, defaultProps) {
        super(defaultProps);
        this.baseSleepTimeSecs = 1;
        this.baseJitterSecs = 1;
        this.streamingIngestClient = new streamingIngestClient_1.default(engineKcsb, defaultProps);
        this.queuedIngestClient = new ingestClient_1.default(dmKcsb, defaultProps);
        if (this.streamingIngestClient.defaultDatabase && this.streamingIngestClient.defaultDatabase !== this.queuedIngestClient.defaultDatabase) {
            throw new Error(`Default database for streaming ingest client (${this.streamingIngestClient.defaultDatabase}) must match default database for queued ingest client (${this.queuedIngestClient.defaultDatabase})`);
        }
        this.defaultDatabase = this.streamingIngestClient.defaultDatabase;
    }
    /**
     * Use Readable for Node.js and ArrayBuffer in browser
     */
    async ingestFromStream(stream, ingestionProperties, clientRequestId) {
        var _a;
        this.ensureOpen();
        const props = this._getMergedProps(ingestionProperties);
        let descriptor = stream instanceof descriptors_1.StreamDescriptor ? stream : new descriptors_1.StreamDescriptor(stream);
        let result = core_util_1.isNode ? await (0, streamUtils_1.tryStreamToArray)(descriptor.stream, maxStreamSize) : descriptor.stream;
        descriptor = new descriptors_1.StreamDescriptor(result).merge(descriptor);
        let streamingResult = null;
        // tryStreamToArray returns a Buffer in NodeJS impl if stream size is small enouph
        if ((core_util_1.isNode && result instanceof Buffer) || !core_util_1.isNode) {
            streamingResult = await this.streamWithRetries(core_util_1.isNode ? (_a = descriptor.size) !== null && _a !== void 0 ? _a : 0 : descriptor.stream.byteLength, descriptor, props, clientRequestId, result);
            result = core_util_1.isNode ? (0, streamUtils_1.readableToStream)(result) : descriptor.stream;
        }
        return streamingResult !== null && streamingResult !== void 0 ? streamingResult : this.queuedIngestClient.ingestFromStream(new descriptors_1.StreamDescriptor(result).merge(descriptor), props);
    }
    /**
     * Use string for Node.js and Blob in browser
     */
    async ingestFromFile(file, ingestionProperties) {
        this.ensureOpen();
        const stream = file instanceof fileDescriptor_1.FileDescriptor ? await (0, streamUtils_1.tryFileToBuffer)(file) : await (0, streamUtils_1.tryFileToBuffer)(new fileDescriptor_1.FileDescriptor(file));
        return await this.ingestFromStream(stream, ingestionProperties);
    }
    async ingestFromBlob(blob, ingestionProperties, clientRequestId) {
        var _a;
        const props = this._getMergedProps(ingestionProperties);
        const descriptor = blob instanceof descriptors_1.BlobDescriptor ? blob : new descriptors_1.BlobDescriptor(blob);
        // No need to check blob size if it was given to us that it's not empty
        await descriptor.fillSize();
        const streamingResult = await this.streamWithRetries((_a = descriptor.size) !== null && _a !== void 0 ? _a : 0, descriptor, props, clientRequestId);
        return streamingResult !== null && streamingResult !== void 0 ? streamingResult : this.queuedIngestClient.ingestFromBlob(descriptor, props);
    }
    async streamWithRetries(length, descriptor, props, clientRequestId, stream) {
        const isBlob = descriptor instanceof descriptors_1.BlobDescriptor;
        if (length <= maxStreamSize) {
            // If we get buffer that means it was less than the max size, so we can do streamingIngestion
            const retry = new retry_1.ExponentialRetry(attemptCount, this.baseSleepTimeSecs, this.baseJitterSecs);
            while (retry.shouldTry()) {
                try {
                    const sourceId = clientRequestId !== null && clientRequestId !== void 0 ? clientRequestId : `KNC.executeManagedStreamingIngest${isBlob ? "FromBlob" : "FromStream"};${descriptor.sourceId};${retry.currentAttempt}`;
                    if (isBlob) {
                        return this.streamingIngestClient.ingestFromBlob(descriptor, props, sourceId);
                    }
                    if (core_util_1.isNode) {
                        return await this.streamingIngestClient.ingestFromStream(new descriptors_1.StreamDescriptor((0, streamUtils_1.readableToStream)(stream)).merge(descriptor), props, sourceId);
                    }
                    return await this.streamingIngestClient.ingestFromStream(descriptor, props, sourceId);
                }
                catch (err) {
                    const oneApiError = err;
                    if (oneApiError["@permanent"]) {
                        throw err;
                    }
                    await retry.backoff();
                }
            }
            stream = isBlob ? undefined : core_util_1.isNode && stream ? (0, streamUtils_1.readableToStream)(stream) : descriptor.stream;
        }
        return null;
    }
    close() {
        if (!this._isClosed) {
            this.streamingIngestClient.close();
            this.queuedIngestClient.close();
        }
        super.close();
    }
}
exports.default = KustoManagedStreamingIngestClient;
//# sourceMappingURL=managedStreamingIngestClient.js.map