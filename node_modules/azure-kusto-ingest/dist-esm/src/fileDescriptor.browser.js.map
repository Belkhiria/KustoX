{"version":3,"file":"fileDescriptor.browser.js","sourceRoot":"","sources":["../../src/fileDescriptor.browser.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,IAAI,MAAM,MAAM,CAAC;AACxB,OAAO,EAAE,kBAAkB,EAAE,eAAe,EAAsB,6BAA6B,EAAE,MAAM,kBAAkB,CAAC;AAC1H,OAAO,EAA4B,0BAA0B,EAAE,MAAM,0BAA0B,CAAC;AAEhG,MAAM,OAAO,cAAe,SAAQ,kBAAkB;IAOlD,YACa,IAAU,EACnB,WAA0B,IAAI,EAC9B,OAAsB,IAAI,EAC1B,kBAAmC,eAAe,CAAC,IAAI,EAC9C,SAAkB,EAClB,IAAa;QAEtB,KAAK,CAAC,QAAQ,CAAC,CAAC;QAPP,SAAI,GAAJ,IAAI,CAAM;QAIV,cAAS,GAAT,SAAS,CAAS;QAClB,SAAI,GAAJ,IAAI,CAAS;QAGtB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC;QAC9B,IAAI,CAAC,MAAM,GAAG,eAAe,KAAK,eAAe,CAAC,IAAI,IAAI,IAAI,CAAC,SAAS,KAAK,KAAK,IAAI,IAAI,CAAC,SAAS,KAAK,MAAM,CAAC;QAChH,IAAI,CAAC,iBAAiB,GAAG,CAAC,6BAA6B,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAC5E,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,mBAA8C;QACxD,MAAM,yBAAyB,GAAG,CAAC,0BAA0B,CAAC,mBAAmB,CAAC,CAAC;QACnF,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI,CAAC,yBAAyB,EAAE,CAAC;YACxE,IAAI,CAAC;gBACD,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;gBACzD,OAAO,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YAC/B,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACT,kCAAkC;YACtC,CAAC;QACL,CAAC;QAED,OAAO,IAAI,CAAC,IAAI,CAAC;IACrB,CAAC;IAED,KAAK,CAAC,OAAO;QACT,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YAClB,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;QAC5B,CAAC;IACL,CAAC;IAED,oBAAoB;QAChB,OAAO,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;IACrE,CAAC;CACJ","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport pako from \"pako\";\nimport { AbstractDescriptor, CompressionType, FileDescriptorBase, shouldCompressFileByExtension } from \"./descriptors.js\";\nimport { IngestionPropertiesInput, shouldCompressFileByFormat } from \"./ingestionProperties.js\";\n\nexport class FileDescriptor extends AbstractDescriptor implements FileDescriptorBase {\n    size: number | null;\n    zipped: boolean;\n    compressionType: CompressionType;\n    shouldNotCompress: boolean;\n    cleanupTmp?: () => Promise<void>;\n\n    constructor(\n        readonly file: Blob,\n        sourceId: string | null = null,\n        size: number | null = null,\n        compressionType: CompressionType = CompressionType.None,\n        readonly extension?: string,\n        readonly name?: string,\n    ) {\n        super(sourceId);\n        this.compressionType = compressionType;\n        this.size = size || file.size;\n        this.zipped = compressionType !== CompressionType.None || this.extension === \".gz\" || this.extension === \".zip\";\n        this.shouldNotCompress = !shouldCompressFileByExtension(this.extension);\n    }\n\n    async prepare(ingestionProperties?: IngestionPropertiesInput): Promise<Blob> {\n        const shouldNotCompressByFormat = !shouldCompressFileByFormat(ingestionProperties);\n        if (!this.zipped && !this.shouldNotCompress && !shouldNotCompressByFormat) {\n            try {\n                const gzipped = pako.gzip(await this.file.arrayBuffer());\n                return new Blob([gzipped]);\n            } catch (e) {\n                // Ignore - return the file itself\n            }\n        }\n\n        return this.file;\n    }\n\n    async cleanup(): Promise<void> {\n        if (this.cleanupTmp) {\n            await this.cleanupTmp();\n        }\n    }\n\n    getCompressionSuffix() {\n        return this.compressionType ? `.${this.compressionType}` : \".gz\";\n    }\n}\n"]}