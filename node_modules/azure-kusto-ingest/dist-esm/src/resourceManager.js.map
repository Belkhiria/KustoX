{"version":3,"file":"resourceManager.js","sourceRoot":"","sources":["../../src/resourceManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { Client, KustoDataErrors, TimeUtils } from \"azure-kusto-data\";\nimport { ExponentialRetry } from \"./retry\";\nimport { ContainerClient } from \"@azure/storage-blob\";\n\nconst ATTEMPT_COUNT = 4;\nexport class ResourceURI {\n    constructor(readonly uri: string) {}\n}\n\nexport class IngestClientResources {\n    constructor(\n        readonly securedReadyForAggregationQueues: ResourceURI[] | null = null,\n        readonly failedIngestionsQueues: ResourceURI[] | null = null,\n        readonly successfulIngestionsQueues: ResourceURI[] | null = null,\n        readonly containers: ResourceURI[] | null = null\n    ) {}\n\n    valid() {\n        const resources = [this.securedReadyForAggregationQueues, this.failedIngestionsQueues, this.failedIngestionsQueues, this.containers];\n        return resources.reduce((prev, current) => !!(prev && current), true);\n    }\n}\n\nexport class ResourceManager {\n    public readonly refreshPeriod: number;\n    public refreshPeriodOnError: number;\n    public ingestClientResources: IngestClientResources | null;\n    public ingestClientResourcesLastUpdate: number | null;\n    public authorizationContext: string | null;\n    public authorizationContextLastUpdate: number | null;\n\n    private baseSleepTimeSecs = 1;\n    private baseJitterSecs = 1;\n\n    constructor(readonly kustoClient: Client, readonly isBrowser: boolean = false) {\n        this.refreshPeriod = TimeUtils.toMilliseconds(1, 0, 0);\n        this.refreshPeriodOnError = TimeUtils.toMilliseconds(0, 10, 0);\n\n        this.ingestClientResources = null;\n        this.ingestClientResourcesLastUpdate = null;\n\n        this.authorizationContext = null;\n        this.authorizationContextLastUpdate = null;\n    }\n\n    async refreshIngestClientResources(): Promise<IngestClientResources> {\n        const error = await this.tryRefresh(false);\n        if (!this.ingestClientResources) {\n            throw new Error(`Failed to fetch ingestion resources from service.  ${error?.message}.\\n ${error?.stack}`);\n        }\n\n        return this.ingestClientResources;\n    }\n\n    async getIngestClientResourcesFromService(): Promise<IngestClientResources> {\n        const retry = new ExponentialRetry(ATTEMPT_COUNT, this.baseSleepTimeSecs, this.baseJitterSecs);\n        while (retry.shouldTry()) {\n            try {\n                const cmd = `.get ingestion resources ${this.isBrowser ? `with (EnableBlobCors='true', EnableQueueCors='true', EnableTableCors='true')` : \"\"}`;\n                const response = await this.kustoClient.execute(\"NetDefaultDB\", cmd);\n                const table = response.primaryResults[0];\n                const resoures = new IngestClientResources(\n                    this.getResourceByName(table, \"SecuredReadyForAggregationQueue\"),\n                    this.getResourceByName(table, \"FailedIngestionsQueue\"),\n                    this.getResourceByName(table, \"SuccessfulIngestionsQueue\"),\n                    this.getResourceByName(table, \"TempStorage\")\n                );\n\n                if (!resoures.valid()) {\n                    throw new Error(\"Unexpected error occured - fetched data returned missing resource\");\n                }\n\n                return resoures;\n            } catch (error: unknown) {\n                if (!(error instanceof KustoDataErrors.ThrottlingError)) {\n                    throw error;\n                }\n                await retry.backoff();\n            }\n        }\n        throw new Error(`Failed to get ingestion resources from server - the request was throttled ${ATTEMPT_COUNT} times.`);\n    }\n\n    getResourceByName(table: { rows: () => any }, resourceName: string): ResourceURI[] {\n        const result: ResourceURI[] = [];\n        for (const row of table.rows()) {\n            const typedRow = row as {\n                ResourceTypeName: string;\n                StorageRoot: string;\n            };\n            if (typedRow.ResourceTypeName === resourceName) {\n                result.push(new ResourceURI(typedRow.StorageRoot));\n            }\n        }\n        return result;\n    }\n\n    async refreshAuthorizationContext(): Promise<string> {\n        const error = await this.tryRefresh(true);\n\n        if (this.authorizationContext == null) {\n            throw new Error(`Failed to fetch Authorization context from service.  ${error?.message}.\\n ${error?.stack}`);\n        }\n\n        return this.authorizationContext;\n    }\n\n    async tryRefresh(isAuthContextFetch: boolean): Promise<Error | null> {\n        const resource = isAuthContextFetch ? this.authorizationContext?.trim() : this.ingestClientResources;\n        const lastRefresh = isAuthContextFetch ? this.authorizationContextLastUpdate : this.ingestClientResourcesLastUpdate;\n        const now = Date.now();\n        let error: Error | null = null;\n        if (!resource || !lastRefresh || lastRefresh + this.refreshPeriod <= now) {\n            try {\n                if (isAuthContextFetch) {\n                    this.authorizationContext = await this.getAuthorizationContextFromService();\n                    this.authorizationContextLastUpdate = now;\n                } else {\n                    this.ingestClientResources = await this.getIngestClientResourcesFromService();\n                    this.ingestClientResourcesLastUpdate = now;\n                }\n            } catch (e) {\n                error = e as Error;\n            }\n        }\n\n        return error;\n    }\n\n    async getAuthorizationContextFromService() {\n        const retry = new ExponentialRetry(ATTEMPT_COUNT, this.baseSleepTimeSecs, this.baseJitterSecs);\n        while (retry.shouldTry()) {\n            try {\n                const response = await this.kustoClient.execute(\"NetDefaultDB\", \".get kusto identity token\");\n                const next = response.primaryResults[0].rows().next();\n                if (next.done) {\n                    throw new Error(\"Failed to get authorization context - got empty results\");\n                }\n                return next.value.toJSON<{ AuthorizationContext: string }>().AuthorizationContext;\n            } catch (error: unknown) {\n                if (!(error instanceof KustoDataErrors.ThrottlingError)) {\n                    throw error;\n                }\n                await retry.backoff();\n            }\n        }\n        throw new Error(`Failed to get identity token from server - the request was throttled ${ATTEMPT_COUNT} times.`);\n    }\n\n    async getIngestionQueues() {\n        return (await this.refreshIngestClientResources()).securedReadyForAggregationQueues;\n    }\n\n    async getFailedIngestionsQueues() {\n        return (await this.refreshIngestClientResources()).failedIngestionsQueues;\n    }\n\n    async getSuccessfulIngestionsQueues() {\n        return (await this.refreshIngestClientResources()).successfulIngestionsQueues;\n    }\n\n    async getContainers() {\n        return (await this.refreshIngestClientResources()).containers;\n    }\n\n    async getAuthorizationContext(): Promise<string> {\n        return this.refreshAuthorizationContext();\n    }\n\n    async getBlockBlobClient(blobName: string) {\n        const containers = await this.getContainers();\n        if (containers == null) {\n            throw new Error(\"Failed to get containers\");\n        }\n        const container = containers[Math.floor(Math.random() * containers.length)];\n        const containerClient = new ContainerClient(container.uri);\n        return containerClient.getBlockBlobClient(blobName);\n    }\n\n    close() {\n        this.kustoClient.close();\n    }\n}\n\nexport default ResourceManager;\n"]}