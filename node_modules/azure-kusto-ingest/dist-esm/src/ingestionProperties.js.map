{"version":3,"file":"ingestionProperties.js","sourceRoot":"","sources":["../../src/ingestionProperties.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { IngestionPropertiesValidationError } from \"./errors\";\nimport { ColumnMapping } from \"./columnMappings\";\n\n/**\n * Data formats supported for Kusto ingestion.\n */\nexport enum DataFormat {\n    /**\n     * Comma-separated value.\n     */\n    CSV = \"csv\",\n    /**\n     * Tab-separated value.\n     */\n    TSV = \"tsv\",\n    /**\n     * Semicolon-separated value (the unique Azure Storage log format).\n     */\n    SCSV = \"scsv\",\n    /**\n     * Start-Of-Header (CTRL-A)-separated value.\n     */\n    SOHSV = \"sohsv\",\n    /**\n     * Pipeline-separated value (used by Cosmos).\n     */\n    PSV = \"psv\",\n    /**\n     * Each record is a line and has just one field.\n     */\n    TXT = \"txt\",\n    /**\n     * Whole stream is a single record with a single field.\n     */\n    RAW = \"raw\",\n    /**\n     * Tab-separated value with '\\' escaping character.\n     */\n    TSVE = \"tsve\",\n    /**\n     * Data is in a JSON format, each line is record with a single JSON value.\n     */\n    JSON = \"json\",\n    /**\n     * Data stream holds a single JSON value -- newlines are regular whitespace.\n     */\n    SINGLEJSON = \"singlejson\",\n    /**\n     * The data stream is a concatenation of JSON documents (property bags all).\n     */\n    MULTIJSON = \"multijson\",\n    /**\n     * Avro format.\n     */\n    AVRO = \"avro\",\n    /**\n     * Parquet format.\n     */\n    PARQUET = \"parquet\",\n    /**\n     * Microsoft Cosmos structured streams format\n     */\n    SSTREAM = \"sstream\",\n    /**\n     * The Optimized Row Columnar (ORC)\n     */\n    ORC = \"orc\",\n    /**\n     * Avro format for ingesting through avro2json.\n     */\n    APACHEAVRO = \"apacheavro\",\n    /**\n     * W3C Extended Log File format.\n     */\n    W3CLogFile = \"w3clogfile\",\n}\n\nexport enum IngestionMappingKind {\n    CSV = \"Csv\",\n    JSON = \"Json\",\n    AVRO = \"Avro\",\n    PARQUET = \"Parquet\",\n    SSTREAM = \"SStream\",\n    ORC = \"orc\",\n    APACHEAVRO = \"ApacheAvro\",\n    W3CLOGFILE = \"W3CLogFile\",\n}\n\nexport const dataFormatMappingKind = (dataFormat: DataFormat): IngestionMappingKind => {\n    switch (dataFormat) {\n        case DataFormat.CSV:\n            return IngestionMappingKind.CSV;\n        case DataFormat.TSV:\n            return IngestionMappingKind.CSV;\n        case DataFormat.SCSV:\n            return IngestionMappingKind.CSV;\n        case DataFormat.SOHSV:\n            return IngestionMappingKind.CSV;\n        case DataFormat.PSV:\n            return IngestionMappingKind.CSV;\n        case DataFormat.TXT:\n            return IngestionMappingKind.CSV;\n        case DataFormat.RAW:\n            return IngestionMappingKind.CSV;\n        case DataFormat.TSVE:\n            return IngestionMappingKind.CSV;\n        case DataFormat.JSON:\n            return IngestionMappingKind.JSON;\n        case DataFormat.SINGLEJSON:\n            return IngestionMappingKind.JSON;\n        case DataFormat.MULTIJSON:\n            return IngestionMappingKind.JSON;\n        case DataFormat.AVRO:\n            return IngestionMappingKind.AVRO;\n        case DataFormat.PARQUET:\n            return IngestionMappingKind.PARQUET;\n        case DataFormat.SSTREAM:\n            return IngestionMappingKind.SSTREAM;\n        case DataFormat.ORC:\n            return IngestionMappingKind.ORC;\n        case DataFormat.APACHEAVRO:\n            return IngestionMappingKind.APACHEAVRO;\n        case DataFormat.W3CLogFile:\n            return IngestionMappingKind.W3CLOGFILE;\n        default:\n            throw new IngestionPropertiesValidationError(`Unsupported data format: ${dataFormat}`);\n    }\n};\n\nexport enum ValidationOptions {\n    DoNotValidate = 0,\n    ValidateCsvInputConstantColumns = 1,\n    ValidateCsvInputColumnLevelOnly = 2,\n}\n\nexport enum ValidationImplications {\n    Fail = 0,\n    BestEffort = 1,\n}\n\nexport class ValidationPolicy {\n    constructor(\n        readonly validationOptions: ValidationOptions = ValidationOptions.DoNotValidate,\n        readonly validationImplications: ValidationImplications = ValidationImplications.BestEffort\n    ) {}\n\n    toJSON(): Record<string, number> {\n        return {\n            ValidationOptions: this.validationOptions,\n            ValidationImplications: this.validationImplications,\n        };\n    }\n}\n\nexport enum ReportLevel {\n    FailuresOnly = 0,\n    DoNotReport = 1,\n    FailuresAndSuccesses = 2,\n}\n\nexport enum ReportMethod {\n    Queue = 0,\n    Table,\n    QueueAndTable,\n}\n\nexport interface IngestionPropertiesFields {\n    database?: string;\n    table?: string;\n    format?: DataFormat;\n    /**\n     * @deprecated. Use ingestionMappingColumns instead.\n     */\n    ingestionMapping?: ColumnMapping[];\n    ingestionMappingColumns?: ColumnMapping[];\n    ingestionMappingReference?: string;\n    /**\n     * @deprecated. Use ingestionMappingKind instead.\n     */\n    ingestionMappingType?: IngestionMappingKind;\n    ingestionMappingKind?: IngestionMappingKind;\n    additionalTags?: string;\n    ingestIfNotExists?: string;\n    ingestByTags?: string[];\n    dropByTags?: string[];\n    flushImmediately?: boolean;\n    ignoreFirstRecord?: boolean;\n    reportLevel?: ReportLevel;\n    reportMethod?: ReportMethod;\n    validationPolicy?: ValidationPolicy;\n    additionalProperties?: { [additional: string]: any } | null;\n}\n\n// This trick lets us avoid duplicating all the properties from the interface. See https://github.com/microsoft/TypeScript/issues/3407\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IngestionProperties extends IngestionPropertiesFields {}\n\n// eslint-disable-next-line no-redeclare\nexport class IngestionProperties {\n    constructor(data: Partial<IngestionPropertiesFields>) {\n        Object.assign(this, data);\n    }\n\n    validate() {\n        if (!this.database) throw new IngestionPropertiesValidationError(\"Must define a target database\");\n        if (!this.table) throw new IngestionPropertiesValidationError(\"Must define a target table\");\n        if (!this.format) throw new IngestionPropertiesValidationError(\"Must define a data format\");\n\n        if (this.ingestionMappingType && !this.ingestionMappingKind) {\n            this.ingestionMappingKind = this.ingestionMappingType;\n        }\n\n        if (this.ingestionMapping && !this.ingestionMappingColumns) {\n            this.ingestionMappingColumns = this.ingestionMapping;\n        }\n\n        if (!this.ingestionMappingColumns && !this.ingestionMappingReference) {\n            if (this.ingestionMappingKind) {\n                throw new IngestionPropertiesValidationError(\n                    \"Cannot define ingestionMappingKind without either ingestionMappingColumns or\" + \" ingestionMappingReference\"\n                );\n            }\n        } else {\n            const mappingKind = dataFormatMappingKind(this.format);\n            if (this.ingestionMappingKind && this.ingestionMappingKind !== mappingKind) {\n                throw new IngestionPropertiesValidationError(\n                    `Mapping kind '${this.ingestionMappingKind}' does not match format '${this.format}' (should be '${mappingKind}')`\n                );\n            }\n            if (this.ingestionMappingColumns) {\n                if (this.ingestionMappingReference) {\n                    throw new IngestionPropertiesValidationError(\"Cannot define both ingestionMappingColumns and ingestionMappingReference\");\n                }\n\n                if (this.ingestionMappingColumns.length === 0) {\n                    throw new IngestionPropertiesValidationError(\"Must define at least one column mapping\");\n                }\n\n                const wrongMappings = this.ingestionMappingColumns\n                    .filter((m) => m.mappingKind !== mappingKind)\n                    .map(\n                        (m) => `Mapping kind mismatch for column '${m.columnName}' - expected data format kind -  '${mappingKind}', but was '${m.mappingKind}'`\n                    );\n                if (wrongMappings.length > 0) {\n                    throw new IngestionPropertiesValidationError(`Invalid columns:\\n${wrongMappings.join(\"\\n\")}`);\n                }\n            }\n        }\n    }\n\n    merge(extraProps: IngestionPropertiesInput) {\n        const merged = new IngestionProperties(this);\n\n        if (!extraProps) {\n            return merged;\n        }\n\n        const assign = <K extends keyof IngestionPropertiesFields, V extends IngestionPropertiesFields[K]>(\n            obj: IngestionPropertiesFields,\n            prop: K,\n            value: V\n        ) => {\n            obj[prop] = value;\n        };\n\n        for (const key of Object.keys(extraProps) as (keyof IngestionPropertiesFields)[]) {\n            if (extraProps[key]) {\n                assign(merged, key, extraProps[key]);\n            }\n        }\n\n        return merged;\n    }\n\n    setDefaults() {\n        if (!this.format) {\n            this.format = DataFormat.CSV;\n        }\n        if (!this.reportLevel) {\n            this.reportLevel = ReportLevel.FailuresOnly;\n        }\n        if (!this.reportMethod) {\n            this.reportMethod = ReportMethod.Queue;\n        }\n    }\n}\n\nexport type IngestionPropertiesInput = IngestionProperties | IngestionPropertiesFields | null | undefined;\n\nexport default IngestionProperties;\n"]}