"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileDescriptor = void 0;
const zlib_1 = __importDefault(require("zlib"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const tmp_promise_1 = require("tmp-promise");
const util_1 = require("util");
const descriptors_1 = require("./descriptors");
/**
 * Describes a file to be ingested. Use string to describe a local path in Node.JS and Blob object in browsers
 */
class FileDescriptor extends descriptors_1.AbstractDescriptor {
    constructor(
    /**
     * Use string in Node.JS and Blob in browser
     */
    file, sourceId = null, size = null, compressionType = descriptors_1.CompressionType.None, extension, // Extracted from file name by default
    name // Extracted from file name by default
    ) {
        super(sourceId, size);
        this.file = file;
        this.extension = extension;
        this.name = name;
        this.compressionType = compressionType;
        this.name = name ? name : path_1.default.basename(this.file);
        this.extension = extension ? extension : path_1.default.extname(this.file).toLowerCase();
        this.zipped = compressionType !== descriptors_1.CompressionType.None || this.extension === ".gz" || this.extension === ".zip";
    }
    async _gzip() {
        const { path, cleanup } = await (0, tmp_promise_1.file)({ postfix: ".gz", keep: false });
        this.cleanupTmp = cleanup;
        const zipper = zlib_1.default.createGzip();
        const input = fs_1.default.createReadStream(this.file, { autoClose: true });
        const output = fs_1.default.createWriteStream(path);
        await new Promise((resolve, reject) => {
            input
                .pipe(zipper)
                .pipe(output)
                .on("error", (err) => {
                reject(err);
            });
            output.once("close", () => {
                resolve(null);
            });
        });
        return path;
    }
    async prepare() {
        if (this.zipped) {
            const estimatedCompressionModifier = 11;
            await this._calculateSize(estimatedCompressionModifier);
            return this.file;
        }
        const path = await this._gzip();
        await this._calculateSize();
        return path;
    }
    async _calculateSize(modifier = 1) {
        if (this.size == null || this.size <= 0) {
            const asyncStat = (0, util_1.promisify)(fs_1.default.stat);
            this.size = (await asyncStat(this.file)).size * modifier;
        }
    }
    async cleanup() {
        if (this.cleanupTmp) {
            await this.cleanupTmp();
        }
    }
    getCompressionSuffix() {
        return this.compressionType ? `.${this.compressionType}` : ".gz";
    }
}
exports.FileDescriptor = FileDescriptor;
//# sourceMappingURL=fileDescriptor.js.map