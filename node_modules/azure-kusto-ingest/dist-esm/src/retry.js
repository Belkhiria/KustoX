"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExponentialRetry = exports.sleep = void 0;
const sleep = (ms) => {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
};
exports.sleep = sleep;
class ExponentialRetry {
    constructor(attemptCount, sleepBaseSecs, maxJitterSecs) {
        this.attemptCount = attemptCount;
        this.sleepBaseSecs = sleepBaseSecs;
        this.maxJitterSecs = maxJitterSecs;
        this.currentAttempt = 0;
    }
    async backoff() {
        if (!this.shouldTry()) {
            throw new Error("Max retries exceeded");
        }
        this.currentAttempt++;
        if (!this.shouldTry()) {
            // This was the last retry - no need to sleep
            return;
        }
        const base = this.sleepBaseSecs * Math.pow(2, this.currentAttempt - 1);
        const jitter = Math.floor(this.maxJitterSecs * Math.random());
        await (0, exports.sleep)(1000 * (base + jitter));
    }
    shouldTry() {
        return this.currentAttempt < this.attemptCount;
    }
}
exports.ExponentialRetry = ExponentialRetry;
//# sourceMappingURL=retry.js.map