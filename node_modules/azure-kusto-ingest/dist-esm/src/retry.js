// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
export const sleep = (ms) => {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
};
export class ExponentialRetry {
    constructor(attemptCount, sleepBaseSecs, maxJitterSecs) {
        this.attemptCount = attemptCount;
        this.sleepBaseSecs = sleepBaseSecs;
        this.maxJitterSecs = maxJitterSecs;
        this.currentAttempt = 0;
    }
    async backoff() {
        if (!this.shouldTry()) {
            throw new Error("Max retries exceeded");
        }
        this.currentAttempt++;
        if (!this.shouldTry()) {
            // This was the last retry - no need to sleep
            return;
        }
        const base = this.sleepBaseSecs * Math.pow(2, this.currentAttempt - 1);
        const jitter = Math.floor(this.maxJitterSecs * Math.random());
        await sleep(1000 * (base + jitter));
    }
    shouldTry() {
        return this.currentAttempt < this.attemptCount;
    }
}
//# sourceMappingURL=retry.js.map