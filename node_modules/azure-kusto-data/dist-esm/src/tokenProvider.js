"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationKeyTokenProvider = exports.ApplicationCertificateTokenProvider = exports.DeviceLoginTokenProvider = exports.UserPassTokenProvider = exports.AzCliTokenProvider = exports.MsiTokenProvider = exports.UserPromptProvider = exports.TokenCredentialProvider = exports.AzureIdentityProvider = exports.CloudSettingsTokenProvider = exports.CallbackTokenProvider = exports.BasicTokenProvider = exports.TokenProviderBase = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const identity_1 = require("@azure/identity");
const cloudSettings_1 = require("./cloudSettings");
const BEARER_TYPE = "Bearer";
/**
 * This base class abstracts token acquisition for all implementations.
 * The class is build for Lazy initialization, so that the first call, take on instantiation of 'heavy' long-lived class members
 */
class TokenProviderBase {
    context() {
        return {};
    }
    constructor(kustoUri) {
        this.kustoUri = kustoUri;
        if (kustoUri != null) {
            const suffix = (!this.kustoUri.endsWith("/") ? "/" : "") + ".default";
            this.scopes = [kustoUri + suffix];
        }
    }
}
exports.TokenProviderBase = TokenProviderBase;
/**
 * Basic Token Provider keeps and returns a token received on construction
 */
class BasicTokenProvider extends TokenProviderBase {
    constructor(kustoUri, token) {
        super(kustoUri);
        this.token = token;
    }
    acquireToken() {
        return Promise.resolve({
            tokenType: BEARER_TYPE,
            accessToken: this.token,
        });
    }
}
exports.BasicTokenProvider = BasicTokenProvider;
/**
 * Callback Token Provider generates a token based on a callback function provided by the caller
 */
class CallbackTokenProvider extends TokenProviderBase {
    constructor(kustoUri, callback) {
        super(kustoUri);
        this.callback = callback;
    }
    async acquireToken() {
        const token = await this.callback();
        return { tokenType: BEARER_TYPE, accessToken: token };
    }
}
exports.CallbackTokenProvider = CallbackTokenProvider;
/**
 * Token providers that require cloud settings to be configured - msal and azure identity
 */
class CloudSettingsTokenProvider extends TokenProviderBase {
    additionalCloudSettingsInit() { }
    constructor(kustoUri) {
        super(kustoUri);
        this.initialized = false;
    }
    async acquireToken() {
        if (!this.initialized) {
            if (this.cloudInfo == null) {
                this.cloudInfo = await cloudSettings_1.CloudSettings.getCloudInfoForCluster(this.kustoUri);
                let resourceUri = this.cloudInfo.KustoServiceResourceId;
                if (this.cloudInfo.LoginMfaRequired) {
                    resourceUri = resourceUri.replace(".kusto.", ".kustomfa.");
                }
                this.scopes = [resourceUri + "/.default"];
                this.additionalCloudSettingsInit();
                this.initClient();
            }
            this.initialized = true;
        }
        const token = await this.acquireTokenWithCloudSettings();
        if (token) {
            return { tokenType: token.tokenType, accessToken: token.accessToken };
        }
        throw new Error("Failed to get token from msal");
    }
    context() {
        return Object.assign(Object.assign({}, super.context()), { kustoUri: this.kustoUri });
    }
}
exports.CloudSettingsTokenProvider = CloudSettingsTokenProvider;
class AzureIdentityProvider extends CloudSettingsTokenProvider {
    constructor(kustoUri, authorityId, timeoutMs) {
        super(kustoUri);
        this.authorityId = authorityId;
        this.timeoutMs = timeoutMs;
    }
    initClient() {
        this.credential = this.getCredential();
    }
    async acquireTokenWithCloudSettings() {
        const response = await this.credential.getToken(this.scopes, {
            requestOptions: {
                timeout: this.timeoutMs,
            },
            tenantId: this.authorityId,
        });
        if (response === null) {
            throw new Error("Failed to get token from msal");
        }
        return { tokenType: BEARER_TYPE, accessToken: response.token };
    }
    context() {
        let base = Object.assign(Object.assign({}, super.context()), { kustoUri: this.kustoUri, authorityId: this.authorityId });
        if (this.timeoutMs) {
            base = Object.assign(Object.assign({}, base), { timeoutMs: this.timeoutMs });
        }
        return base;
    }
}
exports.AzureIdentityProvider = AzureIdentityProvider;
/**
 * TokenCredentialProvider receives any TokenCredential to create a token with.
 */
class TokenCredentialProvider extends AzureIdentityProvider {
    constructor(kustoUri, tokenCredential, timeoutMs) {
        super(kustoUri, undefined, timeoutMs);
        this.tokenCredential = tokenCredential;
    }
    getCredential() {
        return this.tokenCredential;
    }
}
exports.TokenCredentialProvider = TokenCredentialProvider;
/**
 * UserPromptProvider will pop up a login prompt to acquire a token.
 */
class UserPromptProvider extends AzureIdentityProvider {
    constructor(kustoUri, interactiveCredentialOptions, timeoutMs) {
        super(kustoUri, interactiveCredentialOptions === null || interactiveCredentialOptions === void 0 ? void 0 : interactiveCredentialOptions.tenantId, timeoutMs);
        this.interactiveCredentialOptions = interactiveCredentialOptions;
        // The default port is 80, which can lead to permission errors, so we'll choose another port
        this.MinPort = 20000;
        this.MaxPort = 65536;
    }
    getCredential() {
        var _a, _b, _c, _d;
        return new identity_1.InteractiveBrowserCredential(Object.assign(Object.assign({}, this.interactiveCredentialOptions), { tenantId: this.authorityId, clientId: (_b = (_a = this.interactiveCredentialOptions) === null || _a === void 0 ? void 0 : _a.clientId) !== null && _b !== void 0 ? _b : this.cloudInfo.KustoClientAppId, redirectUri: (_d = (_c = this.interactiveCredentialOptions) === null || _c === void 0 ? void 0 : _c.redirectUri) !== null && _d !== void 0 ? _d : `http://localhost:${this.getRandomPortInRange()}/` }));
    }
    getRandomPortInRange() {
        return Math.floor(Math.random() * (this.MaxPort - this.MinPort) + this.MinPort);
    }
    context() {
        var _a, _b;
        let base = super.context();
        if ((_a = this.interactiveCredentialOptions) === null || _a === void 0 ? void 0 : _a.loginHint) {
            base = Object.assign(Object.assign({}, base), { loginHint: (_b = this.interactiveCredentialOptions) === null || _b === void 0 ? void 0 : _b.loginHint });
        }
        return base;
    }
}
exports.UserPromptProvider = UserPromptProvider;
/**
 * MSI Token Provider obtains a token from the MSI endpoint
 * The args parameter is a dictionary conforming with the ManagedIdentityCredential initializer API arguments
 */
class MsiTokenProvider extends AzureIdentityProvider {
    constructor(kustoUri, clientId, authorityId, timeoutMs) {
        super(kustoUri, authorityId, timeoutMs);
        this.clientId = clientId;
    }
    getCredential() {
        return this.clientId ? new identity_1.ManagedIdentityCredential(this.clientId) : new identity_1.ManagedIdentityCredential();
    }
    context() {
        return Object.assign(Object.assign({}, super.context()), { clientId: this.clientId });
    }
}
exports.MsiTokenProvider = MsiTokenProvider;
/**
 * AzCli Token Provider obtains a refresh token from the AzCli cache and uses it to authenticate with MSAL
 */
class AzCliTokenProvider extends AzureIdentityProvider {
    getCredential() {
        return new identity_1.AzureCliCredential();
    }
}
exports.AzCliTokenProvider = AzCliTokenProvider;
/**
 * Acquire a token from MSAL with username and password
 */
class UserPassTokenProvider extends AzureIdentityProvider {
    constructor(kustoUri, userName, password, authorityId, timeoutMs) {
        super(kustoUri, authorityId, timeoutMs);
        this.userName = userName;
        this.password = password;
    }
    getCredential() {
        return new identity_1.UsernamePasswordCredential(this.authorityId, this.cloudInfo.KustoClientAppId, this.userName, this.password);
    }
    context() {
        return Object.assign(Object.assign({}, super.context()), { userName: this.userName, homeAccountId: this.homeAccountId });
    }
}
exports.UserPassTokenProvider = UserPassTokenProvider;
/**
 * Acquire a token from  Device Login flow
 */
class DeviceLoginTokenProvider extends AzureIdentityProvider {
    constructor(kustoUri, deviceCodeCallback, authorityId, timeoutMs) {
        super(kustoUri, authorityId, timeoutMs);
        this.deviceCodeCallback = deviceCodeCallback;
    }
    getCredential() {
        return new identity_1.DeviceCodeCredential({
            tenantId: this.authorityId,
            clientId: this.cloudInfo.KustoClientAppId,
            userPromptCallback: this.deviceCodeCallback,
        });
    }
}
exports.DeviceLoginTokenProvider = DeviceLoginTokenProvider;
/**
 * Acquire a token from MSAL using application certificate
 * Passing the public certificate is optional and will result in Subject Name & Issuer Authentication
 */
class ApplicationCertificateTokenProvider extends AzureIdentityProvider {
    constructor(kustoUri, appClientId, certPrivateKey, certPath, sendX5c, authorityId, timeoutMs) {
        super(kustoUri, authorityId, timeoutMs);
        this.appClientId = appClientId;
        this.certPrivateKey = certPrivateKey;
        this.certPath = certPath;
        this.sendX5c = sendX5c;
    }
    getCredential() {
        if (this.certPrivateKey) {
            return new identity_1.ClientCertificateCredential(this.authorityId, this.appClientId, {
                certificate: this.certPrivateKey,
            }, {
                sendCertificateChain: this.sendX5c,
            });
        }
        return new identity_1.ClientCertificateCredential(this.authorityId, this.appClientId, this.certPath, {
            sendCertificateChain: this.sendX5c,
        });
    }
    context() {
        return Object.assign(Object.assign({}, super.context()), { clientId: this.appClientId, sendX5c: this.sendX5c });
    }
}
exports.ApplicationCertificateTokenProvider = ApplicationCertificateTokenProvider;
/**
 * Acquire a token from MSAL with application id and Key
 */
class ApplicationKeyTokenProvider extends AzureIdentityProvider {
    constructor(kustoUri, appClientId, appKey, authorityId, timeoutMs) {
        super(kustoUri, authorityId, timeoutMs);
        this.appClientId = appClientId;
        this.appKey = appKey;
    }
    getCredential() {
        return new identity_1.ClientSecretCredential(this.authorityId, // The tenant ID in Azure Active Directory
        this.appClientId, // The app registration client Id in the AAD tenant
        this.appKey // The app registration secret for the registered application
        );
    }
    context() {
        return Object.assign(Object.assign({}, super.context()), { clientId: this.appClientId });
    }
}
exports.ApplicationKeyTokenProvider = ApplicationKeyTokenProvider;
//# sourceMappingURL=tokenProvider.js.map